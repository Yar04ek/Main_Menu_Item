/**
 * @name Table
 */
import { Component, PureComponent, ReactNode, SyntheticEvent } from 'react';
import * as React from 'react';
import { OnChangeMeta } from 'react-movable/lib/types';
import { FocusSensorAddProps, FocusSensorProps } from '../global/focus-sensor-hoc';
import { SelectionItem } from './selection';
import { SelectionShortcutsAddProps, SelectionShortcutsProps } from './selection-shortcuts-hoc';
import { DisableHoverAddProps, DisableHoverProps } from './disable-hover-hoc';
import Row from './row-with-focus-sensor';
import { Column, SortParams } from './header-cell';
export interface ReorderParams<T> {
    data: T[];
    oldIndex: number;
    newIndex: number;
}
export interface TableProps<T extends SelectionItem> extends FocusSensorAddProps<HTMLTableRowElement>, SelectionShortcutsAddProps<T>, DisableHoverAddProps {
    data: readonly T[];
    columns: readonly Column<T>[] | ((item: T | null) => readonly Column<T>[]);
    isItemSelectable: (item: T) => boolean;
    loading: boolean;
    onSort: (params: SortParams) => void;
    onReorder: (params: ReorderParams<T>) => void;
    getItemKey: (item: T) => string | number;
    sortKey: string;
    sortOrder: boolean;
    draggable: boolean;
    alwaysShowDragHandle: boolean;
    dragHandleTitle?: string;
    stickyHeader: boolean;
    wideFirstColumn: boolean;
    getItemLevel: (item: T) => number;
    getItemClassName: (item: T) => string | null | undefined;
    getMetaColumnClassName: (item: T) => string | null | undefined;
    getItemDataTest: (item: T) => string | null | undefined;
    isItemCollapsible: (item: T) => boolean;
    isParentCollapsible: (item: T) => boolean;
    isItemCollapsed: (item: T) => boolean;
    onItemCollapse: (item: T) => void;
    onItemExpand: (item: T) => void;
    onItemDoubleClick: (item: T) => void;
    onItemClick: (item: T, e: React.MouseEvent<HTMLTableRowElement>) => void;
    remoteSelection: boolean;
    isDisabledSelectionVisible: (item: T) => boolean;
    getCheckboxTooltip: (item: T) => string | undefined;
    className?: string | null | undefined;
    loaderClassName?: string | undefined;
    caption?: string | null | undefined;
    stickyHeaderOffset?: string | undefined;
    renderEmpty?: (() => ReactNode) | null | undefined;
    RowComponent: typeof Row;
    customLoader?: ((loaderClassName?: string) => ReactNode) | null | undefined;
}
/**
 * Interactive table with selection and keyboard navigation support.
 */
export declare class Table<T extends SelectionItem> extends PureComponent<TableProps<T>> {
    static defaultProps: {
        isItemSelectable: () => boolean;
        loading: boolean;
        onSort: () => void;
        onReorder: () => void;
        getItemKey: (item: SelectionItem) => string | number;
        sortKey: string;
        sortOrder: boolean;
        draggable: boolean;
        alwaysShowDragHandle: boolean;
        stickyHeader: boolean;
        getItemLevel: () => number;
        getItemClassName: () => null;
        getMetaColumnClassName: () => null;
        getItemDataTest: () => null;
        isItemCollapsible: () => boolean;
        isParentCollapsible: () => boolean;
        isItemCollapsed: () => boolean;
        onItemCollapse: () => void;
        onItemExpand: () => void;
        onItemDoubleClick: () => void;
        onItemClick: () => void;
        remoteSelection: boolean;
        isDisabledSelectionVisible: () => boolean;
        getCheckboxTooltip: () => undefined;
        RowComponent: typeof Row;
        wideFirstColumn: boolean;
    };
    state: {
        shortcutsScope: string;
        userSelectNone: boolean;
    };
    componentDidMount(): void;
    componentDidUpdate({ data, selection, onSelect, selectable, remoteSelection }: TableProps<T>): void;
    componentWillUnmount(): void;
    onMouseDown: (e: React.MouseEvent) => void;
    onMouseUp: () => void;
    onRowFocus: (row: T) => void;
    onRowSelect: (row: T, selected: boolean) => void;
    onSortEnd: ({ oldIndex, newIndex }: OnChangeMeta) => void;
    onCheckboxChange: (e: SyntheticEvent<HTMLInputElement>) => void;
    restoreFocusWithoutScroll: () => void;
    render(): import("react/jsx-runtime").JSX.Element;
}
export type TableAttrs<T extends SelectionItem> = DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>;
export default class TableContainer<T extends SelectionItem> extends Component<TableAttrs<T>> {
    Table: {
        new (props: DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>): {
            state: {
                disabledHover: boolean;
            };
            componentDidMount(): void;
            componentWillUnmount(): void;
            onMouseMove: () => void;
            onKeyDown: (e: KeyboardEvent) => void;
            render(): import("react/jsx-runtime").JSX.Element;
            context: unknown;
            setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
            forceUpdate(callback?: (() => void) | undefined): void;
            readonly props: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>;
            refs: {
                [key: string]: React.ReactInstance;
            };
            shouldComponentUpdate?(nextProps: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>, nextState: Readonly<{}>, nextContext: any): boolean;
            componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
            getSnapshotBeforeUpdate?(prevProps: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>, prevState: Readonly<{}>): any;
            componentDidUpdate?(prevProps: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>, prevState: Readonly<{}>, snapshot?: any): void;
            componentWillMount?(): void;
            UNSAFE_componentWillMount?(): void;
            componentWillReceiveProps?(nextProps: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>, nextContext: any): void;
            UNSAFE_componentWillReceiveProps?(nextProps: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>, nextContext: any): void;
            componentWillUpdate?(nextProps: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>, nextState: Readonly<{}>, nextContext: any): void;
            UNSAFE_componentWillUpdate?(nextProps: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>, nextState: Readonly<{}>, nextContext: any): void;
        };
        new (props: DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>, context: any): {
            state: {
                disabledHover: boolean;
            };
            componentDidMount(): void;
            componentWillUnmount(): void;
            onMouseMove: () => void;
            onKeyDown: (e: KeyboardEvent) => void;
            render(): import("react/jsx-runtime").JSX.Element;
            context: unknown;
            setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
            forceUpdate(callback?: (() => void) | undefined): void;
            readonly props: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>;
            refs: {
                [key: string]: React.ReactInstance;
            };
            shouldComponentUpdate?(nextProps: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>, nextState: Readonly<{}>, nextContext: any): boolean;
            componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
            getSnapshotBeforeUpdate?(prevProps: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>, prevState: Readonly<{}>): any;
            componentDidUpdate?(prevProps: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>, prevState: Readonly<{}>, snapshot?: any): void;
            componentWillMount?(): void;
            UNSAFE_componentWillMount?(): void;
            componentWillReceiveProps?(nextProps: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>, nextContext: any): void;
            UNSAFE_componentWillReceiveProps?(nextProps: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>, nextContext: any): void;
            componentWillUpdate?(nextProps: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>, nextState: Readonly<{}>, nextContext: any): void;
            UNSAFE_componentWillUpdate?(nextProps: Readonly<DisableHoverProps<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>>>, nextState: Readonly<{}>, nextContext: any): void;
        };
        defaultProps: Partial<SelectionShortcutsProps<T, FocusSensorProps<TableProps<T>, HTMLTableRowElement, typeof Table>>> | undefined;
        contextType?: React.Context<any> | undefined;
    };
    render(): import("react/jsx-runtime").JSX.Element;
}
