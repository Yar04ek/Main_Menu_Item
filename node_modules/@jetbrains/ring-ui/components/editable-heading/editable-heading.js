import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useCallback, useEffect } from 'react';
import * as React from 'react';
import classNames from 'classnames';
import Heading, { Levels } from '../heading/heading';
import Button from '../button/button';
import { Size } from '../input/input';
import inputStyles from '../input/input.css';
import getUID from '../global/get-uid';
import Shortcuts from '../shortcuts/shortcuts';
import styles from './editable-heading.css';
export { Levels };
export { Size };
function noop() { }
export const EditableHeading = (props) => {
    const { level = Levels.H1, className, headingClassName, inputClassName, children, isEditing = false, isSavingPossible = false, isSaving = false, embedded = false, size = Size.L, onEdit = noop, onSave = noop, onCancel = noop, autoFocus = true, 'data-test': dataTest, error, disabled, multiline = false, renderMenu = () => null, onFocus, onBlur, onChange, onScroll, maxInputRows, translations = {
        save: 'Save',
        cancel: 'Cancel',
    }, ...restProps } = props;
    const [shortcutsScope] = React.useState(getUID('ring-editable-heading-'));
    const [isInFocus, setIsInFocus] = React.useState(false);
    const [isMouseDown, setIsMouseDown] = React.useState(false);
    const [isInSelectionMode, setIsInSelectionMode] = React.useState(false);
    const textAreaRef = React.useRef(null);
    const [isScrolledToBottom, setIsScrolledToBottom] = React.useState(false);
    const [isOverflow, setIsOverflow] = React.useState(false);
    const hasError = error !== undefined;
    const isSaveDisabled = !isSavingPossible || !children || children.trim() === '' || hasError || isSaving;
    const isCancelDisabled = isSaving;
    const isShortcutsDisabled = !isInFocus || isSaving;
    const shortcutsMap = React.useMemo(() => {
        const map = {};
        if (!isSaveDisabled) {
            map.enter = onSave;
        }
        if (isCancelDisabled) {
            map.esc = onCancel;
        }
        return map;
    }, [isSaveDisabled, isCancelDisabled, onSave, onCancel]);
    const classes = classNames(styles.editableHeading, className, {
        [styles.fullSize]: isEditing && size === Size.FULL,
        [styles.isEditing]: isEditing,
        [styles.error]: hasError,
        [styles.disabled]: disabled,
        [styles.multiline]: multiline,
        [styles.selectionMode]: isInSelectionMode,
    });
    const headingClasses = classNames(styles.heading, headingClassName, styles[`size${size}`]);
    const inputClasses = classNames('ring-js-shortcuts', styles.input, styles.textarea, { [styles.textareaNotOverflow]: !isOverflow }, inputStyles[`size${size}`], styles[`level${level}`], inputClassName);
    const stretch = useCallback((el) => {
        if (!el || !el.style) {
            return;
        }
        el.style.height = '0';
        const { paddingTop, paddingBottom } = window.getComputedStyle(el);
        el.style.height = `${el.scrollHeight - parseFloat(paddingTop) - parseFloat(paddingBottom)}px`;
    }, []);
    const checkValue = useCallback((el) => {
        if (multiline && el != null && el.scrollHeight >= el.clientHeight) {
            stretch(el);
        }
    }, [stretch, multiline]);
    const checkOverflow = useCallback((el) => {
        const scrollHeight = el.scrollHeight || 0;
        const clientHeight = el.clientHeight || 0;
        const scrollTop = el.scrollTop || 0;
        setIsScrolledToBottom(scrollHeight - clientHeight <= scrollTop);
        setIsOverflow(scrollHeight > clientHeight);
    }, [setIsScrolledToBottom]);
    const onHeadingMouseDown = React.useCallback(() => {
        setIsMouseDown(true);
    }, []);
    const onMouseMove = React.useCallback(() => {
        if (!isMouseDown) {
            return;
        }
        setIsInSelectionMode(true);
    }, [isMouseDown]);
    const onMouseUp = React.useCallback(() => {
        if (isMouseDown && !isInSelectionMode && !disabled) {
            onEdit();
        }
        setIsMouseDown(false);
        setIsInSelectionMode(false);
    }, [isMouseDown, isInSelectionMode, disabled, onEdit]);
    const onInputFocus = React.useCallback((e) => {
        setIsInFocus(true);
        checkValue(e.target);
        checkOverflow(e.target);
        onFocus?.(e);
    }, [onFocus, checkOverflow, checkValue]);
    const onInputChange = React.useCallback((e) => {
        checkValue(e.target);
        checkOverflow(e.target);
        onChange?.(e);
    }, [onChange, checkOverflow, checkValue]);
    const onInputScroll = React.useCallback((e) => {
        checkOverflow(e.target);
        onScroll?.(e);
    }, [onScroll, checkOverflow]);
    const onInputBlur = React.useCallback((e) => {
        setIsInFocus(false);
        onBlur?.(e);
    }, [onBlur]);
    useEffect(() => {
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
        return () => {
            window.removeEventListener('mousemove', onMouseMove);
            window.removeEventListener('mouseup', onMouseUp);
        };
    }, [onMouseMove, onMouseUp]);
    return (_jsxs(_Fragment, { children: [_jsxs("div", { className: classes, children: [!disabled && isEditing ? (_jsxs(_Fragment, { children: [_jsx(Shortcuts, { map: shortcutsMap, scope: shortcutsScope, disabled: isShortcutsDisabled }), !multiline ? (_jsx("input", { className: inputClasses, value: children, autoFocus: autoFocus, "data-test": dataTest, disabled: isSaving, onChange: onChange, ...restProps, onFocus: onInputFocus, onBlur: onInputBlur })) : (_jsxs("div", { className: classNames(styles.textareaWrapper, inputStyles[`size${size}`]), children: [_jsx("textarea", { ref: textAreaRef, className: inputClasses, value: children, autoFocus: autoFocus, "data-test": dataTest, disabled: isSaving, onChange: onInputChange, ...restProps, onFocus: onInputFocus, onBlur: onInputBlur, onScroll: onInputScroll, style: { maxHeight: maxInputRows ? `${maxInputRows}lh` : '' } }), !isScrolledToBottom && _jsx("div", { className: styles.textareaFade })] }))] })) : (_jsx("button", { type: "button", className: styles.headingWrapperButton, onMouseDown: onHeadingMouseDown, children: _jsx(Heading, { className: headingClasses, level: level, "data-test": dataTest, children: children }) })), !isEditing && renderMenu(), isEditing && !embedded && (_jsxs(_Fragment, { children: [_jsx(Button, { className: styles.button, primary: true, disabled: isSaveDisabled, loader: isSaving, onClick: onSave, children: translations.save }), _jsx(Button, { className: styles.button, disabled: isCancelDisabled, onClick: onCancel, children: translations.cancel })] }))] }), isEditing && error && _jsx("div", { className: classNames(styles.errorText, inputStyles[`size${size}`]), children: error })] }));
};
export default React.memo(EditableHeading);
