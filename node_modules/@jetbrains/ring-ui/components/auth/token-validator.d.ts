import ExtendableError from 'es6-error';
import AuthStorage, { StoredToken } from './storage';
export interface TokenValidatorConfig {
    scope: string[];
    optionalScopes?: readonly string[] | null | undefined;
}
export declare class TokenValidationError extends ExtendableError {
    cause: Error | undefined;
    authRedirect: true;
    constructor(message: string, cause?: Error);
}
export default class TokenValidator {
    private _getUser;
    private _config;
    private _storage;
    constructor(config: TokenValidatorConfig, getUser: (accessToken: string) => Promise<void>, storage: AuthStorage);
    /**
     * Returns epoch - seconds since 1970.
     * Used for calculation of expire times.
     * @return {number} epoch, seconds since 1970
     * @private
     */
    static _epoch(): number;
    /**
     * @const {number}
     */
    static DEFAULT_REFRESH_BEFORE: number;
    /**
     * Error class for auth token validation
     *
     * @param {string} message Error message
     * @param {Error=} cause Error that caused this error
     */
    static TokenValidationError: typeof TokenValidationError;
    /**
     * Check token validity against all conditions.
     * @returns {Promise.<string>}
     */
    validateTokenLocally(): Promise<string>;
    /**
     * Check token validity against all conditions.
     * @returns {Promise.<string>}
     */
    validateToken(): Promise<string>;
    /**
     * Check if there is a token
     * @param {StoredToken} storedToken
     * @return {Promise.<StoredToken>}
     * @private
     */
    private static _validateExistence;
    /**
     * Check expiration
     * @param {StoredToken} storedToken
     * @return {Promise.<StoredToken>}
     * @private
     */
    private static _validateExpiration;
    /**
     * Check scopes
     * @param {StoredToken} storedToken
     * @return {Promise.<StoredToken>}
     * @private
     */
    private _validateScopes;
    /**
     * Check by error code if token should be refreshed
     * @param {string} error
     * @return {boolean}
     */
    static shouldRefreshToken(error: string | undefined): error is "invalid_grant" | "invalid_request" | "invalid_token";
    /**
     * Check scopes
     * @param {StoredToken} storedToken
     * @return {Promise.<StoredToken>}
     * @private
     */
    _validateAgainstUser(storedToken: StoredToken): Promise<void>;
    /**
     * Token Validator function
     * @typedef {(function(StoredToken): Promise<StoredToken>)} TokenValidator
     */
    /**
     * Gets stored token and applies provided validators
     * @param {TokenValidator[]} validators An array of validation
     * functions to check the stored token against.
     * @return {Promise.<string>} promise that is resolved to access token if the stored token is valid. If it is
     * invalid then the promise is rejected. If invalid token should be re-requested then rejection object will
     * have {authRedirect: true}.
     * @private
     */
    _getValidatedToken(validators: ((token: StoredToken) => void | Promise<void>)[]): Promise<string>;
}
