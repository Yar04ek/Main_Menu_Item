import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Component, createContext } from 'react';
import classNames from 'classnames';
import Popup from '../popup/popup';
import { Listeners } from '../global/dom';
import dataTests from '../global/data-tests';
import scheduleRAF from '../global/schedule-raf';
import Theme, { ThemeProvider } from '../global/theme';
import styles from './tooltip.css';
const scheduleScroll = scheduleRAF();
const TooltipContext = createContext(undefined);
/**
 * @name Tooltip
 */
export default class Tooltip extends Component {
    static defaultProps = {
        title: '',
        selfOverflowOnly: false,
        theme: Theme.DARK,
        popupProps: {},
    };
    state = {
        showPopup: false,
        showNestedPopup: false,
    };
    componentDidMount() {
        if (this.props.title) {
            this.addListeners();
        }
    }
    componentDidUpdate(prevProps) {
        if (!prevProps.title && this.props.title) {
            this.addListeners();
        }
        else if (prevProps.title && !this.props.title) {
            this.listeners.removeAll();
        }
    }
    componentWillUnmount() {
        clearTimeout(this.timeout);
        this.listeners.removeAll();
    }
    static PopupProps = Popup.PopupProps;
    static contextType = TooltipContext;
    timeout;
    listeners = new Listeners();
    containerNode;
    containerRef = (el) => {
        this.containerNode = el;
    };
    tryToShowPopup = () => {
        const { delay, title } = this.props;
        if (!title) {
            return;
        }
        if (delay) {
            this.timeout = window.setTimeout(this.showPopup, delay);
        }
        else {
            this.showPopup();
        }
    };
    showPopup = () => {
        if (this.props.selfOverflowOnly) {
            const { containerNode } = this;
            // rare cases when containerNode is null are possible;
            // probably the collision is due to the asynchronous nature of the code,
            // i.e. this code runs after the component is unmounted,
            // although at first glance it looks unlikely.
            if (!containerNode) {
                return;
            }
            // inline element?
            if (containerNode.clientWidth === 0 && containerNode.clientHeight === 0) {
                return;
            }
            if (containerNode.scrollWidth <= containerNode.clientWidth &&
                containerNode.scrollHeight <= containerNode.clientHeight) {
                return;
            }
        }
        this.context?.onNestedTooltipShow();
        this.setState({ showPopup: true });
    };
    hidePopup = () => {
        clearTimeout(this.timeout);
        this.context?.onNestedTooltipHide();
        this.setState({ showPopup: false });
    };
    addListeners() {
        if (this.containerNode != null) {
            this.listeners.add(this.containerNode, 'mouseenter', this.tryToShowPopup);
            this.listeners.add(this.containerNode, 'mouseleave', ev => {
                if (ev.relatedTarget && this.popup?.container?.contains(ev.relatedTarget)) {
                    return;
                }
                this.hidePopup();
            });
        }
        this.listeners.add(document, 'scroll', () => scheduleScroll(this.hidePopup), { passive: true });
    }
    hideIfMovedOutsidePopup = (ev) => {
        if (!('relatedTarget' in ev) || this.popup?.container?.contains(ev.relatedTarget)) {
            return;
        }
        this.hidePopup();
    };
    popup;
    popupRef = (el) => {
        this.popup = el;
    };
    onNestedTooltipShow = () => {
        this.setState({ showNestedPopup: true });
    };
    onNestedTooltipHide = () => {
        this.setState({ showNestedPopup: false });
    };
    render() {
        const { children, 'data-test': dataTest, title, delay, theme, selfOverflowOnly, popupProps, long, ...restProps } = this.props;
        const ariaProps = typeof title === 'string' && !!title ? { 'aria-label': title, role: 'tooltip' } : {};
        const { onNestedTooltipShow, onNestedTooltipHide } = this;
        const popup = (_jsx(Popup, { trapFocus: false, anchorElement: this.containerNode, hidden: !this.state.showPopup || this.state.showNestedPopup, onCloseAttempt: this.hidePopup, maxHeight: 400, attached: false, onMouseOut: this.hideIfMovedOutsidePopup, top: 4, dontCloseOnAnchorClick: true, ref: this.popupRef, ...popupProps, className: classNames(styles.tooltip, { [styles.long]: long, [styles.inheritedTheme]: theme === 'inherit' }, popupProps?.className), children: title }));
        return (_jsx(TooltipContext.Provider, { value: { onNestedTooltipShow, onNestedTooltipHide }, children: _jsxs("span", { ...ariaProps, ...restProps, ref: this.containerRef, "data-test": dataTests('ring-tooltip', dataTest), "data-test-title": typeof title === 'string' ? title : undefined, children: [children, theme === 'inherit' ? (popup) : (_jsx(ThemeProvider, { theme: theme, passToPopups: true, WrapperComponent: props => _jsx("span", { ...props }), children: popup }))] }) }));
    }
}
