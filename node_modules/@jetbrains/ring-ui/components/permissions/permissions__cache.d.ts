export interface PermissionType {
    key: string;
}
export interface Project {
    id: string;
}
export interface Permission {
    permission: PermissionType;
    global?: boolean | null | undefined;
    projects?: readonly Project[] | null | undefined;
}
interface PermissionCacheItem {
    global: boolean | null | undefined;
    projectIdSet: Record<string, boolean> | null;
}
/**
 * Converts an array of cached permissions to a a map of a permission key
 * to the respective cached permission.
 *
 * @param { {
 *   permission: {key: string},
 *   global: boolean?,
 *   projects: {id: string}[]?
 * }[] } permissions
 * @param {function} namesConverter a function, which maps a server-side permission name to client-side permission name
 * @return {object} permission cache
 * @private
 */
export default class PermissionCache {
    static GLOBAL_PROJECT_ID: string;
    /**
     * Convert an array of projects to a set of project ids.
     *
     * @param {object[]=} projects
     * @return {object} a set of project ids
     * @private
     */
    private static _toProjectIdSet;
    namesConverter: (name: string) => string | null | undefined;
    constructor(permissions?: readonly Permission[] | null | undefined, namesConverter?: ((name: string) => string | null | undefined) | null | undefined);
    private _permissions?;
    permissionCache?: Record<string, PermissionCacheItem>;
    set(permissions?: readonly Permission[] | null | undefined): this;
    get(): readonly Permission[] | null | undefined;
    /**
     * Checks if the current user has the given permissions in the project with the given id.
     *
     * @param {string} permissions  space separated list of permissions
     * @param {string=} projectId     optional projectId. If absent the method checks
     *  if the given permission is granted in any project.
     *
     * @return {boolean}
     */
    has(permissions?: string | null | undefined, projectId?: string | null | undefined): boolean;
    /**
     * Lexes permission query string to an array of lexems.
     *
     * @param {string} query
     * @return {string[]}
     */
    lex(query?: string | null | undefined): string[];
    /**
     * @param {string[]} lexems
     * @param {string=} projectId
     * @return {boolean}
     */
    or(lexems: string[], projectId?: string | null | undefined): boolean;
    /**
     * @param {string[]} lexems
     * @param {string=} projectId
     * @return {boolean}
     */
    and(lexems: string[], projectId?: string | null | undefined): boolean;
    /**
     * @param {string[]} lexems
     * @param {string=} projectId
     * @return {boolean}
     */
    not(lexems: string[], projectId?: string | null | undefined): boolean;
    /**
     * @param {string[]} lexems
     * @param {string=} projectId
     * @return {boolean}
     */
    term(lexems: string[], projectId?: string | null | undefined): boolean;
    /**
     * @param {string} permissionName
     * @param {string=} projectId
     * @return {boolean}
     */
    testPermission(permissionName: string, projectId?: string | null | undefined): boolean;
}
export {};
