import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { PureComponent } from 'react';
import classNames from 'classnames';
import getEventKey from '../global/get-event-key';
import Select from '../select/select';
import TagsList from '../tags-list/tags-list';
import Caret from '../caret/caret';
import memoize from '../global/memoize';
import rerenderHOC from '../global/rerender-hoc';
import { Size } from '../input/input';
import { ControlsHeightContext } from '../global/controls-height';
import getUID from '../global/get-uid';
import inputStyles from '../input/input.css';
import ControlLabel from '../control-label/control-label';
import styles from './tags-input.css';
function noop() { }
/**
 * @name Tags Input
 */
const POPUP_VERTICAL_SHIFT = 2;
export default class TagsInput extends PureComponent {
    static defaultProps = {
        dataSource: noop,
        onAddTag: noop,
        onRemoveTag: noop,
        customTagComponent: null,
        maxPopupHeight: 500,
        minPopupWidth: 360,
        canNotBeEmpty: false,
        disabled: false,
        autoOpen: false,
        renderOptimization: true,
        allowAddNewTags: false,
        filter: { fn: () => true },
        placeholder: 'Select an option',
        size: Size.M,
    };
    constructor(props) {
        super(props);
        this.ngModelStateField = TagsInput.ngModelStateField;
    }
    state = {
        tags: [],
        prevTags: null,
        suggestions: [],
        loading: true,
        focused: false,
        query: '',
        activeIndex: 0,
    };
    static getDerivedStateFromProps({ tags }, { prevTags }) {
        const nextState = { prevTags: tags };
        if (tags != null && tags !== prevTags) {
            Object.assign(nextState, { tags, activeIndex: tags.length });
        }
        return nextState;
    }
    componentDidMount() {
        if (this.props.autoOpen && !this.props.disabled) {
            this.focusInput();
            this.loadSuggestions();
            this.select?._showPopup();
        }
    }
    static ngModelStateField = 'tags';
    ngModelStateField;
    static contextType = ControlsHeightContext;
    id = this.props.id || getUID('ring-tags-list-');
    node;
    nodeRef = (node) => {
        this.node = node;
    };
    input;
    caret;
    getInputNode() {
        if (!this.input) {
            this.input = this.select?.filter;
            if (this.input) {
                this.caret = new Caret(this.input);
            }
        }
        return this.input;
    }
    setActiveIndex(activeIndex) {
        this.setState({ activeIndex });
    }
    focusInput = () => {
        this.getInputNode()?.focus();
    };
    focus = () => {
        this.focusInput();
    };
    addTag = (tag) => {
        if (tag == null) {
            return;
        }
        const isUniqueTag = this.state.tags.filter(item => tag.key === item.key).length === 0;
        this.select?.clear();
        this.select?.filterValue('');
        if (isUniqueTag) {
            this.setState(prevState => ({
                tags: prevState.tags.concat([tag]),
            }));
            this.props.onAddTag({ tag });
            this.setActiveIndex();
        }
    };
    onRemoveTag(tagToRemove) {
        return Promise.resolve(this.props.onRemoveTag({ tag: tagToRemove })).then(() => {
            const tags = this.state.tags.filter(tag => tag !== tagToRemove);
            if (this.node) {
                this.setState({ tags });
                this.focusInput();
            }
            return tags;
        }, this.focusInput);
    }
    clickHandler = (event) => {
        if (event.target !== this.node && event.target.parentElement !== this.node) {
            return;
        }
        this.select?._clickHandler();
    };
    filterExistingTags = (suggestions) => {
        const tagsMap = new Map(this.state.tags.map(tag => [tag.key, tag]));
        return suggestions.filter(suggestion => !tagsMap.has(suggestion.key));
    };
    loadSuggestions = (query = '') => this.setState({ loading: true, query }, async () => {
        try {
            const suggestionsResult = this.props.dataSource({ query });
            const allSuggestions = Array.isArray(suggestionsResult) ? suggestionsResult : await suggestionsResult;
            const suggestions = this.filterExistingTags(allSuggestions);
            if (this.node && query === this.state.query) {
                this.setState({ suggestions, loading: false });
            }
        }
        catch (e) {
            this.setState({ loading: false });
        }
    });
    _focusHandler = () => {
        this.setActiveIndex(null);
        this.setState({ focused: true });
    };
    _blurHandler = () => {
        this.setState({ focused: false });
    };
    selectTag = (moveForward) => {
        const activeIndex = typeof this.state.activeIndex === 'number' ? this.state.activeIndex : this.state.tags.length + 1;
        let newActiveIndex = activeIndex + (moveForward ? 1 : -1);
        if (newActiveIndex >= this.state.tags.length) {
            newActiveIndex = this.state.tags.length - 1;
        }
        else if (newActiveIndex < 0) {
            newActiveIndex = 0;
        }
        if (this.state.activeIndex !== newActiveIndex) {
            this.setActiveIndex(newActiveIndex);
        }
    };
    handleKeyDown = (event) => {
        const key = getEventKey(event);
        const isInputFocused = () => event.target instanceof Element && event.target.matches(this.getInputNode()?.tagName ?? '');
        if (key === ' ' && this.props.allowAddNewTags) {
            event.stopPropagation();
            const value = this.getInputNode()?.value;
            if (value != null && value !== '') {
                this.handleTagCreation(value);
            }
            return true;
        }
        if (this.select?._popup?.isVisible()) {
            return true;
        }
        if (key === 'ArrowLeft') {
            if (this.getInputNode() && this.caret != null && Number(this.caret.getPosition()) > 0) {
                return true;
            }
            this.selectTag();
            return false;
        }
        if (key === 'ArrowRight' && !isInputFocused()) {
            if (this.state.activeIndex === this.state.tags.length - 1) {
                if (!this.props.disabled) {
                    this.getInputNode()?.focus();
                    this.setActiveIndex();
                }
            }
            else {
                this.selectTag(true);
            }
            return false;
        }
        if (!this.props.disabled) {
            if (key === 'Backspace' && !this.getInputNode()?.value) {
                event.preventDefault();
                const tagsLength = this.state.tags.length;
                this.select?._hidePopup(true); // otherwise confirmation may be overlapped by popup
                this.onRemoveTag(this.state.tags[tagsLength - 1]);
                return false;
            }
            if ((key === 'Delete' || key === 'Backspace') &&
                this.state.activeIndex != null &&
                this.state.tags[this.state.activeIndex]) {
                this.onRemoveTag(this.state.tags[this.state.activeIndex]).then(() => this.selectTag(true));
                return false;
            }
        }
        return true;
    };
    handleClick = memoize((tag) => () => {
        this.setActiveIndex(this.state.tags.indexOf(tag));
    });
    handleRemove = memoize((tag) => () => this.onRemoveTag(tag));
    handleTagCreation = (label) => {
        this.addTag({ key: label, label });
    };
    select;
    selectRef = (el) => {
        this.select = el;
    };
    render() {
        const { focused, tags, activeIndex } = this.state;
        const { disabled, canNotBeEmpty, allowAddNewTags, filter, size, labelType, height = this.context, label, } = this.props;
        const classes = classNames(styles.tagsInput, [inputStyles[`size${size}`]], [inputStyles[`height${height}`]], {
            [styles.tagsInputDisabled]: disabled,
            [styles.tagsInputFocused]: focused,
        }, this.props.className);
        return (_jsxs("div", { 
            // it transfers focus to input
            role: "presentation", className: classes, onKeyDown: this.handleKeyDown, onClick: this.clickHandler, ref: this.nodeRef, children: [label && (_jsx(ControlLabel, { htmlFor: this.id, disabled: disabled, type: labelType, children: label })), _jsx(TagsList, { tags: tags, activeIndex: activeIndex, disabled: disabled, canNotBeEmpty: canNotBeEmpty, handleRemove: this.handleRemove, className: styles.tagsList, tagClassName: styles.tag, handleClick: this.handleClick, customTagComponent: this.props.customTagComponent, children: _jsx(Select, { id: this.id, ref: this.selectRef, size: Select.Size.AUTO, type: Select.Type.INPUT_WITHOUT_CONTROLS, inputPlaceholder: this.props.placeholder, data: this.state.suggestions, className: classNames(styles.tagsSelect), onSelect: this.addTag, onFocus: this._focusHandler, onBlur: this._blurHandler, renderOptimization: this.props.renderOptimization, add: allowAddNewTags ? { prefix: 'Add new tag' } : undefined, onAdd: allowAddNewTags ? this.handleTagCreation : undefined, filter: filter, maxHeight: this.props.maxPopupHeight, minWidth: this.props.minPopupWidth, top: POPUP_VERTICAL_SHIFT, loading: this.state.loading, onFilter: this.loadSuggestions, onBeforeOpen: this.loadSuggestions, onKeyDown: this.handleKeyDown, disabled: this.props.disabled, loadingMessage: this.props.loadingMessage, notFoundMessage: this.props.notFoundMessage, hint: this.props.hint }) })] }));
    }
}
export const RerenderableTagsInput = rerenderHOC(TagsInput);
