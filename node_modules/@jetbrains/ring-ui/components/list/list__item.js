import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { PureComponent } from 'react';
import classNames from 'classnames';
import dataTests from '../global/data-tests';
import Avatar, { Size as AvatarSize } from '../avatar/avatar';
import Checkbox from '../checkbox/checkbox';
import Icon from '../icon/icon';
import getUID from '../global/get-uid';
import Link, { linkHOC } from '../link/link';
import styles from './list.css';
import { Type } from './consts';
import { getListClasses } from './list__classes';
/**
 * @constructor
 * @extends {ReactComponent}
 */
const RING_UNIT = 8;
const DEFAULT_PADDING = 8;
const CHECKBOX_WIDTH = 28;
export default class ListItem extends PureComponent {
    id = getUID('list-item-');
    stopBubbling = (e) => e.stopPropagation();
    _isString = (val) => typeof val === 'string' || val instanceof String;
    render() {
        const { disabled, checkbox, avatar, subavatar, glyph, icon, rightGlyph, description, label, title, details, hover, level, tabIndex, onClick, onCheckboxChange, onMouseOver, onMouseDown, onMouseUp, rightNodes, leftNodes, showGeneratedAvatar, username, labelWrapper, rgItemType, scrolling, 'data-test': dataTest, className, url, LinkComponent, compact, hoverClassName, children, ...restLinkProps // TODO use an allow list in 8.0
         } = this.props;
        const checkable = checkbox !== undefined;
        const shouldShowGeneratedAvatar = showGeneratedAvatar && username != null;
        const hasLeftNodes = leftNodes || glyph || avatar || shouldShowGeneratedAvatar;
        const showCheckbox = checkable && (checkbox || !hasLeftNodes || (hover && !disabled));
        const classes = getListClasses(this.props);
        const detailsClasses = classNames({
            [styles.details]: details,
            [styles.padded]: icon !== undefined || checkbox !== undefined || glyph !== undefined,
        });
        const style = {
            paddingLeft: `${(Number(level) || 0) * RING_UNIT + DEFAULT_PADDING + (showCheckbox ? CHECKBOX_WIDTH : 0)}px`,
        };
        let computedTitle = null;
        if (this._isString(title)) {
            // if title is specified and is a string then use it
            computedTitle = title;
        }
        else {
            // otherwise use label if it is a string;
            // label can also be an element, use empty string in this case
            computedTitle = this._isString(label) ? label : '';
        }
        const isLink = rgItemType === Type.LINK;
        const combinedDataTest = dataTests({
            'ring-list-item': (dataTest || '').indexOf('ring-list-item') === -1,
            'ring-list-item-action': !disabled,
            'ring-list-item-selected': checkbox,
            'ring-list-link': isLink,
        }, dataTest);
        const labelElement = (_jsx("span", { className: styles.label, title: computedTitle, "data-test": "ring-list-item-label", children: label ?? children }));
        const commonProps = {
            id: this.id,
            tabIndex,
            onClick,
            onMouseOver,
            onMouseDown,
            onFocus: onMouseOver,
            onMouseUp,
            className: classes,
            style,
            disabled,
            children: (_jsxs(_Fragment, { children: [_jsxs("div", { className: styles.top, onMouseOut: this.stopBubbling, onBlur: this.stopBubbling, children: [!showCheckbox && (_jsxs("div", { className: styles.left, children: [leftNodes, glyph && (_jsx(Icon, { className: styles.glyph, glyph: glyph, size: this.props.iconSize, suppressSizeWarning: this.props.suppressSizeWarning })), (avatar || shouldShowGeneratedAvatar) && (_jsx(Avatar, { className: styles.avatar, url: avatar, size: AvatarSize.Size20, subavatar: subavatar, username: username }))] })), labelWrapper ? labelWrapper(labelElement) : labelElement, description && (_jsx("span", { className: styles.description, "data-test": "ring-list-item-description", children: description })), _jsxs("div", { className: styles.right, children: [rightGlyph && (_jsx(Icon, { className: styles.rightGlyph, glyph: rightGlyph, suppressSizeWarning: this.props.suppressSizeWarning, size: this.props.iconSize })), icon && _jsx("div", { className: styles.icon, style: { backgroundImage: `url("${icon}")` } }), rightNodes] })] }), details && _jsx("div", { className: detailsClasses, children: details })] })),
        };
        const LinkComponentToUse = LinkComponent ? linkHOC(LinkComponent) : Link;
        return (_jsxs("div", { className: styles.itemContainer, "data-test": combinedDataTest, children: [showCheckbox && (_jsx("div", { className: styles.checkboxContainer, children: _jsx(Checkbox, { "aria-labelledby": this.id, checked: checkbox, disabled: disabled, onChange: onCheckboxChange, onClick: this.stopBubbling }) })), isLink ? (_jsx(LinkComponentToUse, { pseudo: !restLinkProps.href, ...commonProps, ...restLinkProps })) : (_jsx("button", { type: "button", ...commonProps }))] }));
    }
}
