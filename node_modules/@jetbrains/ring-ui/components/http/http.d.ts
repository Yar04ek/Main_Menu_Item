import ExtendableError from 'es6-error';
export declare const defaultFetchConfig: RequestInit;
export type HTTPErrorData = Record<string, unknown>;
export declare class HTTPError extends ExtendableError {
    data: HTTPErrorData;
    status: number | undefined;
    constructor(response: Partial<Response>, data?: HTTPErrorData);
}
export declare const CODE: {
    UNAUTHORIZED: number;
};
type Method<T> = (url: string, params?: RequestParams) => Promise<T>;
export interface FetchParams<T = unknown> extends Omit<RequestInit, 'body' | 'headers'> {
    body?: T;
    query?: Record<string, unknown> | undefined;
    headers?: HeadersInit | Record<string, null | undefined>;
}
export interface RequestParams<RawBody extends boolean = true | false> extends FetchParams<RawBody extends true ? BodyInit | null : unknown> {
    sendRawBody?: RawBody;
}
export type RequestParamsWithoutMethod<RawBody extends boolean = boolean> = Omit<RequestParams<RawBody>, 'method'>;
export interface HTTPAuth {
    requestToken(): Promise<string | null> | string | null;
    forceTokenUpdate(): Promise<string | null>;
}
export default class HTTP implements Partial<HTTPAuth> {
    baseUrl: string | null | undefined;
    _requestsMeta: WeakMap<object, Partial<Response>>;
    fetchConfig: RequestInit;
    requestToken?: () => Promise<string | null> | string | null;
    shouldRefreshToken?: (error: string) => boolean;
    forceTokenUpdate?: () => Promise<string | null>;
    constructor(auth?: HTTPAuth, baseUrl?: string | null | undefined, fetchConfig?: RequestInit);
    setAuth: (auth: HTTPAuth) => void;
    setBaseUrl: (baseUrl: string | null | undefined) => void;
    _fetch(...args: Parameters<typeof fetch>): Promise<Response>;
    private _makeRequestUrl;
    private _performRequest;
    private _storeRequestMeta;
    private _processResponse;
    fetch: <T = unknown>(url: string, params?: FetchParams) => Promise<T>;
    authorizedFetch(...args: Parameters<HTTP['_performRequest']>): Promise<any>;
    request: <T = unknown>(url: string, params?: RequestParams) => Promise<T>;
    getMetaForResponse: (response: object) => Partial<Response> | undefined;
    get: <T = unknown>(url: string, params?: RequestParamsWithoutMethod) => Promise<T>;
    post: <T = unknown>(url: string, params?: RequestParamsWithoutMethod) => Promise<T>;
    delete: <T = unknown>(url: string, params?: RequestParamsWithoutMethod) => Promise<T>;
    put: <T = unknown>(url: string, params?: RequestParamsWithoutMethod) => Promise<T>;
    /**
     * Usage: const {promise, abort} = http.abortify(http.get<{id: string}>)('http://test.com');
     * @param method
     */
    abortify: <T>(method: Method<T>) => ((...p: Parameters<Method<T>>) => {
        promise: Promise<T>;
        abort: () => void;
    });
}
export {};
