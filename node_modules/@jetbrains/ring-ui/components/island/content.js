import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, Component } from 'react';
import classNames from 'classnames';
import createResizeDetector from 'element-resize-detector';
import scheduleRAF from '../global/schedule-raf';
import styles from './island.css';
import { ScrollHandlerContext } from './adaptive-island-hoc';
const scheduleScrollAction = scheduleRAF();
const noop = () => { };
const END_DISTANCE = 16;
class Content extends Component {
    static defaultProps = {
        fade: true,
        bottomBorder: false,
        onScroll: noop,
        onScrollToBottom: noop,
    };
    state = {
        scrolledToTop: true,
        scrolledToBottom: false,
    };
    componentWillUnmount() {
        this.scrollableNode = null;
        if (!this.wrapperNode) {
            return;
        }
        this.resizeDetector.removeAllListeners(this.wrapperNode);
    }
    resizeDetector = createResizeDetector({ strategy: 'scroll' });
    wrapperNode;
    setWrapper = (node) => {
        if (!node) {
            return;
        }
        this.wrapperNode = node;
        this.resizeDetector.listenTo(node, this.calculateScrollPosition);
    };
    calculateScrollPosition = () => scheduleScrollAction(() => {
        const { scrollableNode } = this;
        if (!scrollableNode) {
            return;
        }
        this.props.onScroll(scrollableNode);
        const { scrollTop, scrollHeight, offsetHeight } = scrollableNode;
        const scrolledToTop = scrollTop === 0;
        const scrolledToBottom = offsetHeight + scrollTop >= scrollHeight - END_DISTANCE;
        if (scrolledToBottom) {
            this.props.onScrollToBottom?.();
        }
        this.setState({ scrolledToTop, scrolledToBottom });
    });
    scrollableNode;
    setScrollableNodeAndCalculatePosition = (node) => {
        if (!node) {
            return;
        }
        this.scrollableNode = node;
        this.calculateScrollPosition();
    };
    render() {
        const { children, className, bottomBorder, scrollableWrapperClassName, onScroll, onScrollToBottom, fade, tabIndex, ...restProps } = this.props;
        const { scrolledToTop, scrolledToBottom } = this.state;
        const classes = classNames(styles.content, className, {
            [styles.contentWithTopFade]: fade && !scrolledToTop,
            [styles.contentWithBottomFade]: fade && !scrolledToBottom,
            [styles.withTransparentBottomBorder]: bottomBorder,
            [styles.withBottomBorder]: bottomBorder && !scrolledToBottom,
        });
        const scrollableWrapperClasses = classNames(styles.scrollableWrapper, scrollableWrapperClassName);
        return (_jsx("div", { ...restProps, "data-test": "ring-island-content", className: classes, children: _jsxs("div", { tabIndex: tabIndex, className: scrollableWrapperClasses, ref: this.setScrollableNodeAndCalculatePosition, onScroll: fade ? this.calculateScrollPosition : noop, children: [fade && _jsx("div", { ref: this.setWrapper, children: children }), !fade && children] }) }));
    }
}
const ContentWrapper = forwardRef((props, ref) => (_jsx(ScrollHandlerContext.Consumer, { children: onScroll => {
        const addProps = onScroll != null ? { onScroll, bottomBorder: true } : {};
        return _jsx(Content, { ...props, ...addProps, ref: ref });
    } })));
ContentWrapper.displayName = 'ContentWrapper';
export default ContentWrapper;
