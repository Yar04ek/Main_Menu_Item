import { jsx as _jsx } from "react/jsx-runtime";
import { Component } from 'react';
import { createComposedRef } from './composeRefs';
export default function focusSensorHOC(ComposedComponent) {
    class FocusSensor extends Component {
        state = {
            focused: this.props.focused,
        };
        componentDidMount() {
            const { props: { autofocus, scrollOnTableFocus }, node, } = this;
            node?.setAttribute('tabindex', '0');
            if (node != null) {
                node.style.outline = 'none';
            }
            document.addEventListener('focus', this.onFocusCapture, true);
            document.addEventListener('blur', this.onBlurCapture, true);
            if (autofocus) {
                node?.focus({ preventScroll: !scrollOnTableFocus });
            }
        }
        componentDidUpdate(prevProps) {
            const { focused } = this.props;
            const isInFocus = this.node?.contains(document.activeElement);
            if (focused && (!isInFocus || !prevProps.focused)) {
                this.onFocusRestore();
            }
            else if (!focused && prevProps.focused) {
                this.onFocusReset();
            }
        }
        componentWillUnmount() {
            document.removeEventListener('focus', this.onFocusCapture, true);
            document.removeEventListener('blur', this.onBlurCapture, true);
        }
        node;
        _skipNextCapture = false;
        onRefUpdate = (node) => {
            if (node) {
                this.node = node;
            }
        };
        composedRef = createComposedRef();
        onFocusCapture = ({ target }) => {
            if (this._skipNextCapture) {
                this._skipNextCapture = false;
                return;
            }
            const focused = target instanceof Node && this.node?.contains(target);
            if (focused && !this.state.focused) {
                this.setState({ focused: true });
                this.props.onFocus?.();
            }
        };
        onBlurCapture = ({ target }) => {
            const { state: { focused }, node, } = this;
            if (focused) {
                setTimeout(() => {
                    const blurred = target instanceof Node && node?.contains(target) && !node.contains(document.activeElement);
                    if (blurred) {
                        this.setState({ focused: false });
                        this.props.onBlur?.();
                    }
                }, 1);
            }
        };
        onFocusRestore = () => {
            this._skipNextCapture = true;
            this.node?.focus({ preventScroll: !this.props.scrollOnTableFocus });
        };
        onFocusReset = () => {
            this.node?.blur();
        };
        render() {
            const { autofocus, focused, onFocus, onBlur, innerRef, scrollOnTableFocus, ...rest } = this.props;
            return (_jsx(ComposedComponent, { ...rest, innerRef: this.composedRef(innerRef, this.onRefUpdate), focused: this.state.focused, onFocusReset: this.onFocusReset, onFocusRestore: this.onFocusRestore }));
        }
    }
    FocusSensor.defaultProps = {
        ...ComposedComponent.defaultProps,
        focused: false,
        autofocus: false,
        scrollOnTableFocus: true,
        onFocus: () => { },
        onBlur: () => { },
    };
    return FocusSensor;
}
