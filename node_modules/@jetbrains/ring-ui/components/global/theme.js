import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { useMemo, useState, useEffect, forwardRef, useContext, createContext, } from 'react';
import classNames from 'classnames';
import { createPortal } from 'react-dom';
import { PopupTarget, PopupTargetContext } from '../popup/popup.target';
import { getPopupContainer } from '../popup/popup';
import defaultStyles from './variables.css';
import styles from './variables_dark.css';
import getUID from './get-uid';
var Theme;
(function (Theme) {
    Theme["AUTO"] = "auto";
    Theme["LIGHT"] = "light";
    Theme["DARK"] = "dark";
})(Theme || (Theme = {}));
export const ThemeContext = createContext({ theme: Theme.LIGHT });
export const GLOBAL_DARK_CLASS_NAME = 'ring-ui-theme-dark';
const darkMatcher = window.matchMedia('(prefers-color-scheme: dark)');
export function useTheme() {
    const [dark, setDark] = useState(darkMatcher.matches);
    useEffect(() => {
        const onChange = (e) => setDark(e.matches);
        darkMatcher.addEventListener('change', onChange);
        return () => darkMatcher.removeEventListener('change', onChange);
    }, []);
    return dark ? Theme.DARK : Theme.LIGHT;
}
export function useThemeClasses(theme) {
    const systemTheme = useTheme();
    const resolvedTheme = theme === Theme.AUTO ? systemTheme : theme;
    return classNames({
        [styles.dark]: resolvedTheme === Theme.DARK,
        [GLOBAL_DARK_CLASS_NAME]: resolvedTheme === Theme.DARK,
        [defaultStyles.light]: resolvedTheme === Theme.LIGHT,
    });
}
export function WithThemeClasses({ theme, children }) {
    const themeClasses = useThemeClasses(theme);
    return children(themeClasses);
}
export function applyTheme(theme, container) {
    if (theme === Theme.DARK) {
        container.classList.remove(defaultStyles.light);
        container.classList.add(styles.dark);
        container.classList.add(GLOBAL_DARK_CLASS_NAME);
    }
    else {
        container.classList.remove(styles.dark);
        container.classList.remove(GLOBAL_DARK_CLASS_NAME);
        container.classList.add(defaultStyles.light);
    }
}
const DefaultWrapper = forwardRef(function Wrapper(props, ref) {
    return _jsx("div", { ...props, ref: ref });
});
export const ThemeProvider = forwardRef(function ThemeProvider({ theme = Theme.AUTO, className, passToPopups, children, WrapperComponent = DefaultWrapper, target, ...restProps }, ref) {
    const systemTheme = useTheme();
    const resolvedTheme = theme === Theme.AUTO ? systemTheme : theme;
    const id = useMemo(() => getUID('popups-with-theme-'), []);
    const themeValue = useMemo(() => ({ theme: resolvedTheme }), [resolvedTheme]);
    useEffect(() => {
        if (target != null) {
            applyTheme(resolvedTheme, target);
        }
    }, [resolvedTheme, target]);
    const themeClasses = useThemeClasses(theme);
    const parentTarget = useContext(PopupTargetContext);
    return (_jsx(ThemeContext.Provider, { value: themeValue, children: _jsx(WrapperComponent, { ref: ref, className: target != null ? undefined : classNames(className, themeClasses), ...restProps, children: passToPopups ? (_jsx(PopupTarget, { id: id, children: popupTarget => (_jsxs(_Fragment, { children: [children, createPortal(_jsx("div", { className: themeClasses, children: popupTarget }), (parentTarget && getPopupContainer(parentTarget)) || document.body)] })) })) : (children) }) }));
});
export default Theme;
