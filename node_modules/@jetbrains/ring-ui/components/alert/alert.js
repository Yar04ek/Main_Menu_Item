import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { PureComponent } from 'react';
import classNames from 'classnames';
import exceptionIcon from '@jetbrains/icons/exception';
import checkmarkIcon from '@jetbrains/icons/checkmark';
import warningIcon from '@jetbrains/icons/warning';
import closeIcon from '@jetbrains/icons/close';
import Icon, { Color } from '../icon/icon';
import Loader from '../loader-inline/loader-inline';
import { getRect } from '../global/dom';
import dataTests from '../global/data-tests';
import Button from '../button/button';
import Theme, { ThemeProvider } from '../global/theme';
import styles from './alert.css';
export const ANIMATION_TIME = 500;
/**
 * @name Alert
 */
/**
 * List of available alert types.
 * @enum {string}
 */
export var AlertType;
(function (AlertType) {
    AlertType["ERROR"] = "error";
    AlertType["MESSAGE"] = "message";
    AlertType["SUCCESS"] = "success";
    AlertType["WARNING"] = "warning";
    AlertType["LOADING"] = "loading";
})(AlertType || (AlertType = {}));
/**
 * Lookup table of alert type to icon modifier.
 * @type {Object.<AlertType, string>}
 */
const TypeToIcon = {
    [AlertType.ERROR]: exceptionIcon,
    [AlertType.SUCCESS]: checkmarkIcon,
    [AlertType.WARNING]: warningIcon,
};
/**
 * Lookup table of alert type to icon color.
 * @type {Object.<AlertType, Icon.Color>}
 */
const TypeToIconColor = {
    [AlertType.ERROR]: Color.RED,
    [AlertType.SUCCESS]: Color.GREEN,
    [AlertType.WARNING]: Color.WHITE,
};
/**
 * @constructor
 * @name Alert
 * @extends {ReactComponent}
 */
/**
 * **Alert** is a component for displaying contextual notifications. If you want to display a stack of notifications, use **Alerts** instead.
 */
export default class Alert extends PureComponent {
    /** @override */
    static defaultProps = {
        theme: Theme.DARK,
        closeable: true,
        showWithAnimation: true,
        type: AlertType.MESSAGE,
        inline: true,
        isClosing: false,
        isShaking: false,
        timeout: 0,
        onClose: () => { },
        onCloseRequest: () => { },
    };
    state = {
        height: null,
    };
    componentDidMount() {
        if (this.props.timeout > 0) {
            this.hideTimeout = window.setTimeout(this.closeRequest, this.props.timeout);
        }
    }
    componentDidUpdate() {
        if (this.props.isClosing) {
            this._close();
        }
    }
    componentWillUnmount() {
        clearTimeout(this.hideTimeout);
    }
    node;
    hideTimeout;
    static Type = AlertType;
    closeRequest = (event) => {
        this.startCloseAnimation();
        return this.props.onCloseRequest(event);
    };
    startCloseAnimation = () => {
        const height = getRect(this.node).height;
        this.setState({ height });
    };
    _close() {
        this.startCloseAnimation();
        setTimeout(() => {
            this.props.onClose();
        }, ANIMATION_TIME);
    }
    /**
     * @param {SyntheticEvent} evt
     * @private
     */
    _handleCaptionsLinksClick = (evt) => {
        if (evt.target instanceof Element && evt.target.matches('a')) {
            this.closeRequest(evt);
        }
    };
    /**
     * @private
     */
    _getCaption() {
        return (_jsx("span", { className: classNames(styles.caption, this.props.captionClassName, {
                [styles.withCloseButton]: this.props.closeable,
            }), onClick: this._handleCaptionsLinksClick, 
            // We only process clicks on `a` elements, see above
            role: "presentation", children: this.props.children }));
    }
    /**
     * @private
     * @return {XML|string}
     */
    _getIcon() {
        const glyph = TypeToIcon[this.props.type];
        if (glyph) {
            return _jsx(Icon, { glyph: glyph, className: styles.icon, color: TypeToIconColor[this.props.type] || Color.DEFAULT });
        }
        else if (this.props.type === AlertType.LOADING) {
            return _jsx(Loader, { className: styles.loader });
        }
        return '';
    }
    storeAlertRef = (node) => {
        this.node = node;
    };
    render() {
        const { type, inline, isClosing, isShaking, closeButtonClassName, showWithAnimation, className, 'data-test': dataTest, theme, } = this.props;
        const classes = classNames(className, {
            [styles.alert]: true,
            [styles.animationOpen]: showWithAnimation,
            [styles.error]: type === 'error',
            [styles.alertInline]: inline,
            [styles.animationClosing]: isClosing,
            [styles.animationShaking]: isShaking,
        });
        const height = this.state.height;
        const style = height ? { marginBottom: -height } : undefined;
        return (_jsxs(ThemeProvider, { theme: theme, className: classes, "data-test": dataTests('alert', dataTest), "data-test-type": type, style: style, ref: this.storeAlertRef, children: [this._getIcon(), this._getCaption(), this.props.closeable ? (_jsx(Button, { icon: closeIcon, className: classNames(styles.close, closeButtonClassName), "data-test": "alert-close", "aria-label": "close alert", onClick: this.closeRequest })) : ('')] }));
    }
}
export { default as Container } from './container';
