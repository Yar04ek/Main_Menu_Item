import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
/**
 * @name Popup
 */
import { PureComponent } from 'react';
import { createPortal } from 'react-dom';
import classNames from 'classnames';
import getUID from '../global/get-uid';
import scheduleRAF from '../global/schedule-raf';
import { Listeners, getStyles } from '../global/dom';
import Shortcuts from '../shortcuts/shortcuts';
import dataTests from '../global/data-tests';
import TabTrap from '../tab-trap/tab-trap';
import position from './position';
import styles from './popup.css';
import { DEFAULT_DIRECTIONS, Dimension, Directions, Display, MaxHeight, MinWidth } from './popup.consts';
import { PopupTargetContext, PopupTarget } from './popup.target';
export { PopupTargetContext, PopupTarget };
const isPossibleClientSideNavigation = (event) => {
    const target = event.target;
    const link = target.closest('a');
    // Taken from https://github.com/nanostores/router/blob/80a333db4cf0789fda21a02715ebabca15192642/index.js#L58-L69
    return (link &&
        event.button === 0 && // Left mouse button
        link.target !== '_blank' && // Not for new tab
        link.origin === location.origin && // Not external link
        link.rel !== 'external' && // Not external link
        link.target !== '_self' && // Now manually disabled
        !link.download && // Not download link
        !event.altKey && // Not download link by user
        !event.metaKey && // Not open in new tab by user
        !event.ctrlKey && // Not open in new tab by user
        !event.shiftKey && // Not open in new window by user
        !event.defaultPrevented);
};
const stop = (event) => {
    if (!isPossibleClientSideNavigation(event)) {
        event.stopPropagation();
    }
};
export const getPopupContainer = (target) => typeof target === 'string' ? document.querySelector(`[data-portaltarget=${target}]`) : target;
/**
 * @constructor
 * @name Popup
 * @extends {ReactComponent}
 */
export default class Popup extends PureComponent {
    static defaultProps = {
        shortcuts: true,
        hidden: false,
        onOutsideClick() { },
        onEscPress() { },
        onCloseAttempt() { },
        dontCloseOnAnchorClick: false,
        keepMounted: false,
        directions: DEFAULT_DIRECTIONS,
        autoPositioning: true,
        autoPositioningOnScroll: true,
        autoCorrectTopOverflow: true,
        left: 0,
        top: 0,
        offset: 0,
        sidePadding: 8,
        attached: false,
        trapFocus: false,
        autoFocusFirst: false,
        legacy: false,
    };
    state = {
        display: Display.SHOWING,
    };
    componentDidMount() {
        if (!this.props.hidden) {
            this._setListenersEnabled(true);
        }
    }
    componentDidUpdate(prevProps, prevState) {
        const { hidden } = this.props;
        if (this.props !== prevProps) {
            if (prevProps.hidden !== hidden) {
                this._setListenersEnabled(!hidden);
            }
            this._redraw();
        }
        if (this.props.onShow &&
            !hidden &&
            this.state.display === Display.SHOWN &&
            (prevProps.hidden || prevState.display !== Display.SHOWN)) {
            this.props.onShow();
        }
    }
    componentWillUnmount() {
        this._setListenersEnabled(false);
    }
    popup;
    node;
    parent;
    container;
    ringPopupTarget;
    shouldUseShortcuts() {
        const { shortcuts, hidden } = this.props;
        return shortcuts && !hidden;
    }
    listeners = new Listeners();
    redrawScheduler = scheduleRAF(true);
    uid = getUID('popup-');
    calculateDisplay = (prevState) => ({
        ...prevState,
        display: this.props.hidden ? Display.SHOWING : Display.SHOWN,
    });
    static PopupProps = {
        Directions,
        Dimension,
        MinWidth,
        MaxHeight,
    };
    portalRef = (el) => {
        this.node = el;
        this.parent = el && el.parentElement;
        if (el && this.getContainer()) {
            this._redraw();
        }
    };
    popupRef = (el) => {
        this.popup = el;
        this._redraw();
    };
    containerRef = (el) => {
        this.container = el;
    };
    getContainer() {
        const target = this.props.target || this.ringPopupTarget;
        return target && getPopupContainer(target);
    }
    position() {
        const { directions, autoPositioning, autoCorrectTopOverflow, sidePadding, top, left, offset, maxHeight, minWidth } = this.props;
        const container = this.getContainer();
        return position({
            popup: this.popup,
            container: container && getStyles(container).position !== 'static' ? container : null,
            anchor: this._getAnchor(),
            directions,
            autoPositioning,
            autoCorrectTopOverflow,
            sidePadding,
            top,
            left,
            offset,
            maxHeight,
            minWidth,
        });
    }
    _updateDirection = (newDirection) => {
        if (this.state.direction !== newDirection) {
            this.setState({ direction: newDirection });
            if (this.props.onDirectionChange) {
                this.props.onDirectionChange(newDirection);
            }
        }
    };
    _updatePosition = () => {
        const popup = this.popup;
        if (popup) {
            popup.style.position = 'absolute';
            if (this.isVisible()) {
                const { styles: style, direction } = this.position();
                Object.entries(style).forEach(([key, value]) => {
                    const propKey = key;
                    if (typeof value === 'number') {
                        popup.style[propKey] = `${value}px`;
                    }
                    else {
                        popup.style[propKey] = value.toString();
                    }
                });
                if (direction != null) {
                    this._updateDirection(direction);
                }
            }
            this.setState(this.calculateDisplay);
        }
    };
    _redraw = () => {
        if (this.isVisible()) {
            this.redrawScheduler(this._updatePosition);
        }
    };
    _getAnchor() {
        return this.props.anchorElement || this.parent;
    }
    _listenersEnabled;
    _prevTimeout;
    /**
     * @param {boolean} enable
     * @private
     */
    _setListenersEnabled(enable) {
        if (enable && !this._listenersEnabled) {
            clearTimeout(this._prevTimeout);
            this._prevTimeout = window.setTimeout(() => {
                this._listenersEnabled = true;
                this.listeners.add(window, 'resize', this._redraw);
                if (this.props.autoPositioningOnScroll) {
                    this.listeners.add(window, 'scroll', this._redraw);
                }
                this.listeners.add(document, 'pointerdown', this._onDocumentClick, true);
                let el = this._getAnchor();
                while (el) {
                    this.listeners.add(el, 'scroll', this._redraw);
                    el = el.parentElement;
                }
            }, 0);
            return;
        }
        if (!enable && this._listenersEnabled) {
            this.listeners.removeAll();
            clearTimeout(this._prevTimeout);
            this._listenersEnabled = false;
        }
    }
    /**
     * Returns visibility state
     * @return {boolean}
     */
    isVisible() {
        return !this.props.hidden;
    }
    _onCloseAttempt(evt, isEsc) {
        this.props.onCloseAttempt(evt, isEsc);
    }
    _onEscPress = (evt) => {
        this.props.onEscPress(evt);
        this._onCloseAttempt(evt, true);
    };
    /**
     * @param {jQuery.Event} evt
     * @private
     */
    _onDocumentClick = (evt) => {
        if ((this.container && evt.target instanceof Node && this.container.contains(evt.target)) ||
            !this._listenersEnabled ||
            (this.props.dontCloseOnAnchorClick && evt.target instanceof Node && this._getAnchor()?.contains(evt.target))) {
            return;
        }
        this.props.onOutsideClick(evt);
        this._onCloseAttempt(evt, false);
    };
    getInternalContent() {
        const { trapFocus, autoFocusFirst, children } = this.props;
        return trapFocus ? (_jsx(TabTrap, { autoFocusFirst: autoFocusFirst, focusBackOnExit: true, children: children })) : (children);
    }
    shortcutsScope = this.uid;
    shortcutsMap = {
        esc: this._onEscPress,
    };
    render() {
        const { className, style, hidden, attached, keepMounted, client, onMouseDown, onMouseUp, onMouseOver, onMouseOut, onContextMenu, 'data-test': dataTest, largeBorderRadius, } = this.props;
        const showing = this.state.display === Display.SHOWING;
        const classes = classNames(className, styles.popup, {
            [styles.attached]: attached,
            [styles.hidden]: hidden,
            [styles.showing]: showing,
            [styles.largeBorderRadius]: largeBorderRadius,
        });
        const direction = (this.state.direction || '').toLowerCase().replace(/[_]/g, '-');
        return (_jsx(PopupTargetContext.Consumer, { children: value => {
                this.ringPopupTarget = value;
                return (_jsxs("span", { 
                    // prevent bubbling through portal
                    onClick: stop, 
                    // This handler only blocks bubbling through React portal
                    role: "presentation", ref: this.portalRef, children: [this.shouldUseShortcuts() && _jsx(Shortcuts, { map: this.shortcutsMap, scope: this.shortcutsScope }), client !== false &&
                            (keepMounted || !hidden) &&
                            createPortal(_jsx(PopupTarget, { id: this.uid, ref: this.containerRef, onMouseOver: onMouseOver, onFocus: onMouseOver, onMouseOut: onMouseOut, onBlur: onMouseOut, onContextMenu: onContextMenu, children: _jsx("div", { "data-test": dataTests('ring-popup', dataTest), "data-test-shown": !hidden && !showing, "data-test-direction": direction, ref: this.popupRef, className: classes, style: style, onMouseDown: onMouseDown, onMouseUp: onMouseUp, 
                                    // mouse handlers are used to track clicking on inner elements
                                    role: "presentation", children: this.getInternalContent() }) }), this.getContainer() || document.body)] }));
            } }));
    }
}
